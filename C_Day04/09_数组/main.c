/*
#1.数组：连续的一片内存空间，并且这片连续的内存空间被划分为大小相等的小空间
#2.数组是如何划分为大小相等的小空间？为什么需要这么做？
数组只能存放同一种类型的数据，可以随机访问数组元素（在O(1)的时间复杂度内访问数组的任一元素）
#3.为什么在大多数语言中，数组的索引都是从0开始的？
方便寻址 i_addr = base_addr + i*sizeof(element_type) 从零开始
若索引从1开始：i_addr = base_addr + (i - 1)*sizeof(element_type) 从一开始
每次寻址都会多一次减法运算
#4.为什么数组的效率一般会由于链表？
1.数组的内存空间是连续的，而链表的内存空间不连续，导致数组可以更好地利用cpu的高速缓存（cache，预读，局部性原理）
2.数组只需要存储数据，而链表不仅仅要存储数据，还要存储指针域。数组的内存使用率更高
#5.数组的声明
element_type arr_name[size];  int arr[10];
注意事项：size必须是一个整型的常量表达式，在编译期间能计算出数组的大小
#6.数组的初始化
int arr[3] = {1,2,3}
int arr[3] = {1,2}其余元素会初始化为0
int arr[10] = {0}
int arr[] = {1,2,3,4,5}，数组的长度会由编译器自行推断，这里长度5
初始化式的长度不能比数组的长度大
#7.对数组使用sizeof运算符
#define SIZE(a) (sizeof(a)/sizeof(a[0]))
#8.二维数组
类似矩阵，但内部存储是连续的，是行优先存储 第一行，第二行，第三行...
#8.二维数组的初始化
二维数组，其中一个元素是一维数组的数组
#9.常量数组
用const修饰，表明数组的元素不会发生改变
const int digits[2] = { 1, 2 };
作用：存放一些静态数据
*/
#define _CRT_SECURE_NO_WARNINGS
#define N 10
#define M 20
#define X 30
#define SIZE(a) (sizeof(a)/sizeof(a[0]))
#include<stdio.h>
int main(void) {
	int arr[5] = { 1,2,3,4,5 };// 类型为int[5]，变量名为arr
	// int brr[M];
	// int crr[X];
	sizeof(arr);// 20字节
	for (int i = 0; i < SIZE(arr); i++) {
		arr[i] = 0;
	}
	// 二维数组初始化
	int matrix[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };
	int matrix1[3][4] = { {1,2,3},{5,6,7} };//其余元素初始化为0
	int matrix2[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };// 不建议省略内存大括号
	int matrix3[3][4] = { 0 };// 所有元素全部初始化为0
	int matrix3[][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };// 编译器自行推断行数大小
	// 不能省略列的大小
	return 0;
}